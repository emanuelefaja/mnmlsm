<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>mnmlism</title>
  <script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {}
      }
    }
  </script>
  <style>
    .disable-select {
      user-select: none;
      -webkit-user-select: none;
    }
  </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 transition-colors duration-200">
  <div x-data="app()" class="h-screen flex flex-col" :class="{ 'dark': darkMode }">
    <!-- Search bar -->
    <div class="p-0 border-b border-gray-200 dark:border-gray-700 flex items-center bg-white dark:bg-gray-800">
      <input 
        type="text" 
        placeholder="Search or create notes..."
        class="w-full h-full pl-4 pr-0 py-0 rounded-none border-transparent focus:outline-none focus:border-transparent text-sm bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100"
        x-model="searchQuery"
        @keydown.enter.prevent="handleSearchEnter"
        @keydown="handleSearchKeydown"
        @input="searchResultIndex = 0; isSearching = searchQuery.length > 0; if(isSearching && filteredNotes.length > 0) previewSearchResult()"
      >
      <div class="flex items-center pr-2 space-x-2">
        <!-- Sidebar view toggle -->
        <button 
          class="p-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded text-gray-700 dark:text-gray-300"
          :class="{ 'bg-gray-100 dark:bg-gray-700': showSidebar }"
          @click="showSidebar = !showSidebar; showNotesAbove = false"
        >
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 4V20 M12 4V20 M18 4V20"/>
          </svg>
        </button>

        <!-- Table view toggle -->
        <button 
          class="p-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded text-gray-700 dark:text-gray-300"
          :class="{ 'bg-gray-100 dark:bg-gray-700': showNotesAbove }"
          @click="showNotesAbove = !showNotesAbove; showSidebar = false"
        >
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/>
          </svg>
        </button>
      </div>
    </div>

    <!-- Content area container -->
    <div class="flex-1 flex overflow-hidden">
      <!-- Sidebar -->
      <div 
        class="bg-gray-50 dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 relative transition-all"
        :style="`width: ${showSidebar ? sidebarWidth + 'px' : '0'}`"
        x-show="!showNotesAbove"
      >
        <!-- Resize handle -->
        <div 
          class="absolute -right-[5px] w-[10px] top-0 bottom-0 cursor-col-resize"
          @mousedown="startResize"
          x-ref="resizeHandle"
        ></div>
        
        <div class="p-4 h-full overflow-auto">
          <div x-show="!notes.length" class="p-4 text-gray-400 dark:text-gray-500 text-sm">
            Loading notes...
          </div>
          <div class="space-y-1">
            <template x-for="note in filteredNotes" :key="note.path">
              <div 
                class="p-1 hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer rounded group text-gray-900 dark:text-gray-100"
                :class="{ 
                  'bg-blue-50 dark:bg-blue-900/30': note.path === selectedNoteId,
                  'bg-yellow-50 dark:bg-yellow-900/30': isSearching && filteredNotes[searchResultIndex]?.path === note.path
                }"
                @click="selectNote(note.path)"
              >
                <div class="flex flex-col min-w-0">
                  <!-- Show input when renaming -->
                  <template x-if="isRenaming && renameNoteId === note.path">
                    <input 
                      type="text" 
                      class="w-full px-1 py-0 text-sm border-none bg-transparent focus:outline-none text-gray-900 dark:text-gray-100"
                      x-model="renameValue"
                      @keydown.enter.prevent="saveRename()"
                      @keydown.escape.prevent="cancelRename()"
                      @click.stop
                      x-ref="renameInput"
                    />
                  </template>
                  
                  <!-- Show normal title when not renaming -->
                  <template x-if="!(isRenaming && renameNoteId === note.path)">
                    <span 
                      class="font-semibold text-black dark:text-white text-sm truncate" 
                      x-text="note.title.replace(/_/g, ' ')"
                      @dblclick.stop="startRename(note)"
                    ></span>
                  </template>
                </div>
              </div>
            </template>
          </div>
        </div>
      </div>

      <!-- Main Content -->
      <div class="flex-1 flex flex-col overflow-hidden">
        <!-- Notes above content -->
        <div 
          class="bg-gray-50 dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 overflow-auto"
          x-show="showNotesAbove"
          style="max-height: 240px"
        >
          <div class="p-4">
            <table class="w-full table-auto text-sm text-gray-900 dark:text-gray-100">
              <thead class="text-xs font-semibold text-gray-500 dark:text-gray-400">
                <tr>
                  <th class="text-left pb-2">Name</th>
                  <th class="text-left pb-2">Created</th>
                  <th class="text-left pb-2">Updated</th>
                </tr>
              </thead>
              <tbody>
                <template x-for="note in filteredNotes" :key="note.path">
                  <tr 
                    class="hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer"
                    :class="{ 
                      'bg-blue-50 dark:bg-blue-900/30': note.path === selectedNoteId,
                      'bg-yellow-50 dark:bg-yellow-900/30': isSearching && filteredNotes[searchResultIndex]?.path === note.path
                    }"
                    @click="selectNote(note.path)"
                  >
                    <td class="py-2 pr-4 truncate max-w-[200px]" x-text="note.title"></td>
                    <td class="py-2 pr-4 text-gray-500 dark:text-gray-400" x-text="new Date(note.created).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' }) + ', ' + new Date(note.created).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })"></td>
                    <td class="py-2 text-gray-500 dark:text-gray-400" x-text="new Date(note.updated).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' }) + ', ' + new Date(note.updated).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })"></td>
                  </tr>
                </template>
              </tbody>
            </table>
          </div>
        </div>
        
        <!-- Text area container -->
        <div class="flex-1 overflow-auto">
          <textarea 
            class="w-full min-h-full bg-white dark:bg-gray-800 focus:outline-none p-4 text-gray-900 dark:text-gray-100"
            placeholder="Start typing..."
            x-model="activeNoteContent"
            @input="updateActiveNoteContent($event.target.value)"
            x-ref="editor"
            @keydown.ctrl.s.prevent
            @keydown.meta.s.prevent
            @keydown.escape.prevent="focusSearchBar()"
          ></textarea>
        </div>
      </div>
    </div>
  </div>

  <script>
    function app() {
      return {
        searchQuery: '',
        notes: [],
        notesDir: null,
        selectedNoteId: null,
        sidebarWidth: 256,
        isResizing: false,
        startX: 0,
        startWidth: 0,
        showSidebar: true,
        showNotesAbove: false,
        saveTimeout: null,
        activeNoteContent: '',
        isRenaming: false,
        renameNoteId: null,
        renameValue: '',
        darkMode: false,
        searchResultIndex: 0,
        isSearching: false,
        
        get filteredNotes() {
          return this.notes.filter(note => 
            note.title.toLowerCase().includes(this.searchQuery.toLowerCase()) ||
            note.content.toLowerCase().includes(this.searchQuery.toLowerCase())
          )
        },
        
        getActiveNoteContent() {
          const note = this.notes.find(n => n.path === this.selectedNoteId)
          return note ? String(note.content) : ''
        },
        
        async updateActiveNoteContent(value) {
          const note = this.notes.find(n => n.path === this.selectedNoteId)
          if (note) {
            console.log('Updating note:', note.path, 'with content:', value)
            // Immediate local update
            note.content = value;
            note.updated = Date.now();
            this.notes = [...this.notes];
            
            // Immediate save without debounce
            try {
              console.log('Saving note:', note.path)
              await window.electronAPI.updateNote(note.path, value)
              console.log('Save successful for:', note.path)
            } catch (error) {
              console.error('Save error:', error)
            }
          }
        },
        
        selectNote(path) {
          this.selectedNoteId = path;
          // Update activeNoteContent when selecting a note
          const note = this.notes.find(n => n.path === path);
          if (note) {
            this.activeNoteContent = note.content;
          }
        },
        
        startResize(e) {
          this.isResizing = true
          this.startX = e.clientX
          this.startWidth = this.sidebarWidth
          document.body.classList.add('disable-select', 'cursor-col-resize')
          
          document.addEventListener('mousemove', this.handleResize)
          document.addEventListener('mouseup', this.stopResize)
        },
        
        handleResize(e) {
          if (!this.isResizing) return
          const delta = e.clientX - this.startX
          this.sidebarWidth = Math.min(Math.max(200, this.startWidth + delta), 400)
        },
        
        stopResize() {
          this.isResizing = false
          document.body.classList.remove('disable-select', 'cursor-col-resize')
          document.removeEventListener('mousemove', this.handleResize)
          document.removeEventListener('mouseup', this.stopResize)
        },
        
        async init() {
          this.handleResize = this.handleResize.bind(this)
          this.stopResize = this.stopResize.bind(this)
          
          try {
            this.notesDir = await window.electronAPI.chooseNotesDirectory();
            await this.loadNotes();
          } catch (error) {
            console.error('Error initializing notes:', error);
          }
          
          // Watch for changes
          window.electronAPI.onNotesUpdate(() => this.loadNotes());
          
          // Listen for dark mode toggle
          window.electronAPI.onDarkModeToggle((isDarkMode) => {
            this.darkMode = isDarkMode;
            if (isDarkMode) {
              document.documentElement.classList.add('dark');
            } else {
              document.documentElement.classList.remove('dark');
            }
          });
          
          // Listen for focus search event
          window.electronAPI.onFocusSearch(() => {
            this.focusSearchBar();
          });
        },
        
        async loadNotes() {
          try {
            const notes = await window.electronAPI.getNotes(this.notesDir);
            this.notes = notes.map(note => ({
              ...note,
              // Ensure content is properly initialized
              content: String(note.content || '')
            }));
            
            // Reset search state
            this.isSearching = false;
            this.searchResultIndex = 0;
            
            // Force selection of first note with proper reactivity
            if (this.notes.length > 0) {
              this.selectedNoteId = this.notes[0].path;
              // Set activeNoteContent directly
              this.activeNoteContent = this.notes[0].content;
            }
          } catch (error) {
            console.error('Error loading notes:', error);
            this.notes = [];
          }
        },
        
        handleSearchEnter(e) {
          const hasModifier = e.metaKey || e.ctrlKey;
          const shouldCreateNew = this.filteredNotes.length === 0;
          
          if (this.isSearching && this.filteredNotes.length > 0 && !hasModifier) {
            // Select the currently highlighted search result
            this.selectNote(this.filteredNotes[this.searchResultIndex].path);
            this.isSearching = false;
            this.searchQuery = '';
            
            // Focus the editor
            this.$nextTick(() => {
              this.$refs.editor.focus();
            });
          } else if ((shouldCreateNew && !hasModifier) || hasModifier) {
            this.createNote();
          }
        },

        async createNote() {
          const title = this.searchQuery.trim();
          if (!title) return;

          // Generate base filename without counter
          const baseFilename = `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.txt`;
          const content = ""; // Empty content instead of adding a title
          
          try {
            const fullPath = await window.electronAPI.joinPaths(this.notesDir, baseFilename);
            const filePath = await window.electronAPI.createNote(fullPath, content);

            // Add to notes list and select it
            const newNote = {
              path: filePath,
              title,
              content,
              created: Date.now(),
              updated: Date.now()
            };
            
            this.notes = [newNote, ...this.notes];
            this.selectedNoteId = filePath;
            this.searchQuery = '';
            
            await this.loadNotes();
            
            // Focus the editor after creating the note
            this.$nextTick(() => {
              this.$refs.editor.focus();
            });
          } catch (error) {
            console.error('Error creating note:', error);
            alert(`Error creating note: ${error.message}`);
          }
        },

        startRename(note) {
          this.isRenaming = true;
          this.renameNoteId = note.path;
          this.renameValue = note.title.replace(/_/g, ' ');
          
          // Use a longer delay and try multiple times to ensure selection works
          setTimeout(() => {
            const input = document.querySelector(`[x-ref="renameInput"]`);
            if (input) {
              input.focus();
              input.select();
              
              // Try again after a short delay as a fallback
              setTimeout(() => {
                input.focus();
                input.select();
              }, 50);
            }
          }, 100);
          
          // Add document click listener to handle clicks outside
          this.$nextTick(() => {
            document.addEventListener('click', this.handleOutsideClick);
          });
        },

        // Handle clicks outside the rename input
        handleOutsideClick(e) {
          // Check if the click was outside the rename input
          const input = document.querySelector(`[x-ref="renameInput"]`);
          if (input && !input.contains(e.target)) {
            this.saveRename();
            document.removeEventListener('click', this.handleOutsideClick);
          }
        },

        // Clean up the event listener when canceling or saving
        cancelRename() {
          this.isRenaming = false;
          this.renameNoteId = null;
          this.renameValue = '';
          document.removeEventListener('click', this.handleOutsideClick);
        },

        async saveRename() {
          if (!this.isRenaming || !this.renameNoteId) return;
          
          // Remove the click listener
          document.removeEventListener('click', this.handleOutsideClick);
          
          const note = this.notes.find(n => n.path === this.renameNoteId);
          if (!note) return;
          
          const newTitle = this.renameValue.trim();
          if (!newTitle || newTitle === note.title) {
            this.cancelRename();
            return;
          }
          
          try {
            const oldPath = note.path;
            // Use the path helper instead of direct path module
            const pathInfo = await window.electronAPI.getPathInfo(oldPath);
            const newFilename = `${newTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase()}${pathInfo.extname}`;
            const newPath = await window.electronAPI.joinPaths(pathInfo.dirname, newFilename);
            
            // Rename the file on disk
            await window.electronAPI.renameNote(oldPath, newPath);
            
            // Update the note in our local state
            note.title = newTitle;
            note.path = newPath;
            
            // Reset renaming state
            this.isRenaming = false;
            this.renameNoteId = null;
            this.renameValue = '';
            
            // If this was the selected note, update the selectedNoteId
            if (this.selectedNoteId === oldPath) {
              this.selectedNoteId = newPath;
            }
          } catch (error) {
            console.error('Error renaming note:', error);
            alert(`Error renaming note: ${error.message}`);
          }
        },

        focusSearchBar() {
          // Find the search input and focus it
          const searchInput = document.querySelector('input[x-model="searchQuery"]');
          if (searchInput) {
            searchInput.focus();
          }
        },

        handleSearchKeydown(e) {
          if (this.searchQuery && this.filteredNotes.length > 0) {
            this.isSearching = true;
            
            if (e.key === 'ArrowDown') {
              e.preventDefault();
              this.searchResultIndex = Math.min(this.searchResultIndex + 1, this.filteredNotes.length - 1);
              this.previewSearchResult();
            } else if (e.key === 'ArrowUp') {
              e.preventDefault();
              this.searchResultIndex = Math.max(this.searchResultIndex - 1, 0);
              this.previewSearchResult();
            } else if (e.key === 'Escape') {
              e.preventDefault();
              this.clearSearch();
            }
          } else if (e.key === 'Escape' && this.searchQuery) {
            // Clear search even if there are no results
            e.preventDefault();
            this.clearSearch();
          }
        },

        previewSearchResult() {
          if (this.isSearching && this.filteredNotes.length > 0) {
            const note = this.filteredNotes[this.searchResultIndex];
            this.activeNoteContent = note.content;
            // Don't set selectedNoteId yet - just preview the content
          }
        },

        clearSearch() {
          this.searchQuery = '';
          this.isSearching = false;
          this.searchResultIndex = 0;
          
          // Restore the previously selected note content if available
          if (this.selectedNoteId) {
            const note = this.notes.find(n => n.path === this.selectedNoteId);
            if (note) {
              this.activeNoteContent = note.content;
            }
          }
          
          // Keep the search input focused
          this.$nextTick(() => {
            const searchInput = document.querySelector('input[x-model="searchQuery"]');
            if (searchInput) {
              searchInput.focus();
            }
          });
        }
      }
    }
  </script>
</body>
</html> 